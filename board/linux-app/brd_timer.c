#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <time.h>

#include <ostypes.h>
#include <sg_counter.h>
#include <os_api.h>


/* following line will be generated by OIL file system generator tool */
extern void SystemTickISR(void);

timer_t posix_timer;

void brd_systick_handler(int signum) {
	SystemTickISR();
}


int brd_setup_sytimer(void) {
	struct sigaction action;
	struct itimerspec new_value, old_value;
	sigset_t set;

	memset(&action, 0, sizeof(struct sigaction));
	action.sa_handler = brd_systick_handler;
	if (sigaction(SIGALRM, &action, NULL) == -1)
		perror("sigaction");

	if (timer_create(CLOCK_MONOTONIC, NULL, &posix_timer) == -1)
		perror("timer_create");

	new_value.it_interval.tv_sec = 0;
	new_value.it_interval.tv_nsec = OS_TICK_DURATION_ns; /* 1 ms repetition */
	new_value.it_value.tv_sec = 0;
	new_value.it_value.tv_nsec = OS_TICK_DURATION_ns; /* 1 ms */

	if (timer_settime(posix_timer, 0, &new_value, &old_value) == -1)
		perror("timer_settime");

	if (sigemptyset(&set) == -1)
		perror("sigemptyset");

	if (sigaddset(&set, SIGRTMIN) == -1)
		perror("sigaddset");

	if (sigprocmask(SIG_BLOCK, &set, NULL) == -1)
		perror("sigprocmask");

	pr_log("%s() success!\n", __func__);
	return 0;
}

int brd_get_usec_syscount(u32 *ucount) {
	u64 time_us;
	struct timespec tp;
	if (clock_gettime (CLOCK_MONOTONIC, &tp) == -1) {
        	perror ("clock_gettime");
		return -1;
	}

	time_us = tp.tv_sec * 1000000 + tp.tv_nsec / 1000;
	*ucount = (u32)time_us;

	return 0;
}